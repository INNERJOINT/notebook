# 对称加密
## 分组加密
### DES（Data Encryption Standard）
#### 流程
1. 明文64位-》IP置换（打乱）-》分L0（32位）+R0（32位）
2. 密钥64位-》置换选择表1 -》56位（8位为校验位）-》分C0（28位）+D0（28位）-》循环左移产生Ci+Di-》查置换选择表2（再去除8位）获得每轮循环的密钥Ki（48位）
#### 要点
* 每次循环的Li（32位）为上次循环产生的Ri-1（32位）
* Ri（32位）-》拓展置换E-》48位数据和Ki（48位）异或运算-》S盒(**Substitution-box，替换盒**)代替-》P盒(**Permutation-box，置换盒**)置换-》32位数据Ri+1
* 拓展置换E是为了把32位数据和48位的子密钥异或产生的
* 48位输入经过8个S盒运算产生32位输出
* S盒是6位输入4位输出的子运算
* S盒运算步骤：例如输入110111，取第一位和最后一位构成11，即3；然后中间4位1011，即11，查询S-i盒表得到4位数据
* 最后再进行一次逆运算查表即得到密文
#### 流程图
![](http://www.cxyxiaowu.com/wp-content/uploads/2019/10/1571057977-17488ca32598db6.jpg)
![](http://www.cxyxiaowu.com/wp-content/uploads/2019/10/1571057978-6fb896eca9a2484.png)
### 3DES
3DES使用“密钥包”，其包含3个DES密钥，K1，K2和K3，均为56位（除去奇偶校验位）。
加密算法为：
密文 =EK3(DK2(EK1(明文)))
使用K1为密钥进行DES加密，再用K2为密钥进行DES“解密”，最后以K3进行DES加密。
明文 = DK1(EK2(DK3(密文)))

---

### AES（Advanced Encryption Standard）
密钥长度有128bit，192bit和256bit
#### 填充
1. NoPadding：不做任何填充，但是要求明文必须是16字节的整数倍。


2. PKCS5Padding（默认）：<br>如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，且每个字节的值等于缺少的字符数。<br>比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6}

3. ISO10126Padding：<br>如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字节，最后一个字符值等于缺少的字符数，其他字符填充随机数。<br>比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则可能补全为{1,2,3,4,5,a,b,c,d,e,5,c,3,G,$,6}
#### 模式
ECB模式（默认）（不安全，相同明文会产生相同的密文）：
电码本模式    Electronic Codebook Book

CBC模式：
密码分组链接模式    Cipher Block Chaining

CTR模式：
计算器模式    Counter

CFB模式：

密码反馈模式    Cipher FeedBack


OFB模式：

输出反馈模式    Output FeedBack
#### 流程
1. 分组，最后一组按设置的填充模式填充，每一组128bit（16字节）
2. 拓展密钥，4*4*（10+1）字节的数组W存储密钥，W{0-15}同原始密钥，后面的W[i]由W[i-4]和W[i-1]生成
3. ![](https://www.cxyxiaowu.com/wp-content/uploads/2019/10/1572424535-522911bdbcf7c4b.jpg)
#### 破解
* 对于使用用户名产生token来登陆的情况，例如admin只能用token登陆，那么可以使用‘  admin‘空格来尝试跳过检测
* 中间相遇攻击—————已知CipherText = Encrypt(Key2, Encrypt(Key1, PlainText))，则存在X = Encrypt(Key1, PlainText) = Decrypt(Key2, CipherText)的中间相遇攻击（**Meet-in-the-Middle attack，MITM**），穷举X来获取key1和key2
---
## 流加密
### RC4（Rivest Cipher 4）
曾经是一些加密协议使用的算法，如1997年的WEP和2003年的WPA；和1995年的SSL，以及1999年的TLS。
* 产生一个256长度的S盒，每收到一个字节，按一定算法定位S盒中的一个元素，并在这个加密过程中改变了S盒
### Salsa20

---

# 非对称加密
## RSA
### 概要
* 两个不相等的素数**p**（61）和**q**（53） ——》**N**（3233）=p*q ——》则欧拉函数**φ（n）**= (p-1)*(q-1）=3120
* 选择1<e<3120且**与N互质**,例e=17
* 计算d满足e*d=1（mod φ（n））即得到了私钥（n，d）和公钥（n，e）
* 计算m的e次方加密，再对密文进行c的d次方解密
### 重点
* n和e是公开的，破解RSA需要知道d，而由于ed=1（mod φ（n）），φ（n）需要由（p-1）和（q-1）求出来，所以需要进行质因数分解，这是难点。
*  目前成功破解的rsa密钥长度为768位
*  对于加密大于N的明文，主要有两种方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种"对称性加密算法"（比如DES），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。

* 对于密文n如果与N互质，则易证明：![](https://wikimedia.org/api/rest_v1/media/math/render/svg/4f80f4211b08ec150fb0b2930f408678bae5b901)
* 如果密文m与N不互质，则：<br>则明文m为p或q的整数倍，以 m = kp为例,由欧拉定理m有<br>(kp)^(ed) ≡ kp (mod q)**-->**(kp)^(ed) = tq + kp<br>**t必然能被p整除，即 t=t'p(上式左右同除以p，左式必为整数，则右式tq/p也必为整数，所以t/p必为整数）**<br>得到(kp)^(ed) = t'pq + kp<br>m=kp，n=pq,所以**m^(ed) ≡ m (mod n)**
* [参考资料](https://cnodejs.org/topic/5bb9c31e15e4fd1923f48d0b)

### 应用
* 数字签名：发件人将自己的消息哈希后加在消息后面再使用私钥加密发送，收信人使用公钥解密后哈希计算对比一致，说明是发件人发出的消息
* 数字证书：为了防止中间人替换信任的网站的公钥后冒充，将真正的公钥让第三方信任的证书中心来认真，即将信任的网站信息和公钥用第三方的私钥加密生成数字签名后发给用户。